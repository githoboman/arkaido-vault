"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/c32check";
exports.ids = ["vendor-chunks/c32check"];
exports.modules = {

/***/ "(ssr)/./node_modules/c32check/lib/address.js":
/*!**********************************************!*\
  !*** ./node_modules/c32check/lib/address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nconst base58check = __webpack_require__(/*! ./base58check */ \"(ssr)/./node_modules/c32check/lib/base58check.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20, // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21, // 'N'\n    },\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3RHLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFlO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJrYWRpa28tYmVnaW5uZXItd2l6YXJkLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9hZGRyZXNzLmpzP2RhNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmMzMlRvQjU4ID0gZXhwb3J0cy5iNThUb0MzMiA9IGV4cG9ydHMuYzMyYWRkcmVzc0RlY29kZSA9IGV4cG9ydHMuYzMyYWRkcmVzcyA9IGV4cG9ydHMudmVyc2lvbnMgPSB2b2lkIDA7XG5jb25zdCBjaGVja3N1bV8xID0gcmVxdWlyZShcIi4vY2hlY2tzdW1cIik7XG5jb25zdCBiYXNlNThjaGVjayA9IHJlcXVpcmUoXCIuL2Jhc2U1OGNoZWNrXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuZXhwb3J0cy52ZXJzaW9ucyA9IHtcbiAgICBtYWlubmV0OiB7XG4gICAgICAgIHAycGtoOiAyMixcbiAgICAgICAgcDJzaDogMjAsIC8vICdNJ1xuICAgIH0sXG4gICAgdGVzdG5ldDoge1xuICAgICAgICBwMnBraDogMjYsXG4gICAgICAgIHAyc2g6IDIxLCAvLyAnTidcbiAgICB9LFxufTtcbi8vIGFkZHJlc3MgY29udmVyc2lvbiA6IGJpdGNvaW4gdG8gc3RhY2tzXG5jb25zdCBBRERSX0JJVENPSU5fVE9fU1RBQ0tTID0ge307XG5BRERSX0JJVENPSU5fVE9fU1RBQ0tTWzBdID0gZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAycGtoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1s1XSA9IGV4cG9ydHMudmVyc2lvbnMubWFpbm5ldC5wMnNoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1sxMTFdID0gZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAycGtoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1sxOTZdID0gZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAyc2g7XG4vLyBhZGRyZXNzIGNvbnZlcnNpb24gOiBzdGFja3MgdG8gYml0Y29pblxuY29uc3QgQUREUl9TVEFDS1NfVE9fQklUQ09JTiA9IHt9O1xuQUREUl9TVEFDS1NfVE9fQklUQ09JTltleHBvcnRzLnZlcnNpb25zLm1haW5uZXQucDJwa2hdID0gMDtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAyc2hdID0gNTtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAycGtoXSA9IDExMTtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAyc2hdID0gMTk2O1xuLyoqXG4gKiBNYWtlIGEgYzMyY2hlY2sgYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIGFuZCBoYXNoMTYwXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gYSBjMzJjaGVjayBzdHJpbmcgYW5kIGMzMiBhZGRyZXNzXG4gKiBpcyB0aGF0IHRoZSBsZXR0ZXIgJ1MnIGlzIHByZS1wZW5kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSBhZGRyZXNzIHZlcnNpb24gbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaDE2MGhleCAtIHRoZSBoYXNoMTYwIHRvIGVuY29kZSAobXVzdCBiZSBhIGhhc2gxNjApXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBjMzJhZGRyZXNzKHZlcnNpb24sIGhhc2gxNjBoZXgpIHtcbiAgICBpZiAoIWhhc2gxNjBoZXgubWF0Y2goL15bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBub3QgYSBoYXNoMTYwIGhleCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYzMyc3RyaW5nID0gKDAsIGNoZWNrc3VtXzEuYzMyY2hlY2tFbmNvZGUpKHZlcnNpb24sIGhhc2gxNjBoZXgpO1xuICAgIHJldHVybiBgUyR7YzMyc3RyaW5nfWA7XG59XG5leHBvcnRzLmMzMmFkZHJlc3MgPSBjMzJhZGRyZXNzO1xuLyoqXG4gKiBEZWNvZGUgYSBjMzIgYWRkcmVzcyBpbnRvIGl0cyB2ZXJzaW9uIGFuZCBoYXNoMTYwXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyYWRkciAtIHRoZSBjMzJjaGVjay1lbmNvZGVkIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfSBhIHR1cGxlIHdpdGggdGhlIHZlcnNpb24gYW5kIGhhc2gxNjBcbiAqL1xuZnVuY3Rpb24gYzMyYWRkcmVzc0RlY29kZShjMzJhZGRyKSB7XG4gICAgaWYgKGMzMmFkZHIubGVuZ3RoIDw9IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGMzMiBhZGRyZXNzOiBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAoYzMyYWRkclswXSAhPSAnUycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGMzMiBhZGRyZXNzOiBtdXN0IHN0YXJ0IHdpdGggXCJTXCInKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBjaGVja3N1bV8xLmMzMmNoZWNrRGVjb2RlKShjMzJhZGRyLnNsaWNlKDEpKTtcbn1cbmV4cG9ydHMuYzMyYWRkcmVzc0RlY29kZSA9IGMzMmFkZHJlc3NEZWNvZGU7XG4vKlxuICogQ29udmVydCBhIGJhc2U1OGNoZWNrIGFkZHJlc3MgdG8gYSBjMzJjaGVjayBhZGRyZXNzLlxuICogVHJ5IHRvIGNvbnZlcnQgdGhlIHZlcnNpb24gbnVtYmVyIGlmIG9uZSBpcyBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gYjU4Y2hlY2sgLSB0aGUgYmFzZTU4Y2hlY2sgZW5jb2RlZCBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGluZmVycmVkIGZyb20gdGhlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzIgYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciAob3IgdGhlXG4gKiAgIHNlbWFudGljYWxseS1lcXVpdmFsZW50IGMzMiB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGdpdmVuKVxuICovXG5mdW5jdGlvbiBiNThUb0MzMihiNThjaGVjaywgdmVyc2lvbiA9IC0xKSB7XG4gICAgY29uc3QgYWRkckluZm8gPSBiYXNlNThjaGVjay5kZWNvZGUoYjU4Y2hlY2spO1xuICAgIGNvbnN0IGhhc2gxNjBTdHJpbmcgPSAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShhZGRySW5mby5kYXRhKTtcbiAgICBjb25zdCBhZGRyVmVyc2lvbiA9IHBhcnNlSW50KCgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGFkZHJJbmZvLnByZWZpeCksIDE2KTtcbiAgICBsZXQgc3RhY2tzVmVyc2lvbjtcbiAgICBpZiAodmVyc2lvbiA8IDApIHtcbiAgICAgICAgc3RhY2tzVmVyc2lvbiA9IGFkZHJWZXJzaW9uO1xuICAgICAgICBpZiAoQUREUl9CSVRDT0lOX1RPX1NUQUNLU1thZGRyVmVyc2lvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhY2tzVmVyc2lvbiA9IEFERFJfQklUQ09JTl9UT19TVEFDS1NbYWRkclZlcnNpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFja3NWZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIGMzMmFkZHJlc3Moc3RhY2tzVmVyc2lvbiwgaGFzaDE2MFN0cmluZyk7XG59XG5leHBvcnRzLmI1OFRvQzMyID0gYjU4VG9DMzI7XG4vKlxuICogQ29udmVydCBhIGMzMmNoZWNrIGFkZHJlc3MgdG8gYSBiYXNlNThjaGVjayBhZGRyZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IGMzMnN0cmluZyAtIHRoZSBjMzJjaGVjayBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGluZmVycmVkIGZyb20gdGhlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBiYXNlNTggYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciAob3IgdGhlXG4gKiAgICBzZW1hbnRpY2FsbHktZXF1aXZhbGVudCBiaXRjb2luIHZlcnNpb24gbnVtYmVyLCBpZiBub3QgZ2l2ZW4pXG4gKi9cbmZ1bmN0aW9uIGMzMlRvQjU4KGMzMnN0cmluZywgdmVyc2lvbiA9IC0xKSB7XG4gICAgY29uc3QgYWRkckluZm8gPSBjMzJhZGRyZXNzRGVjb2RlKGMzMnN0cmluZyk7XG4gICAgY29uc3Qgc3RhY2tzVmVyc2lvbiA9IGFkZHJJbmZvWzBdO1xuICAgIGNvbnN0IGhhc2gxNjBTdHJpbmcgPSBhZGRySW5mb1sxXTtcbiAgICBsZXQgYml0Y29pblZlcnNpb247XG4gICAgaWYgKHZlcnNpb24gPCAwKSB7XG4gICAgICAgIGJpdGNvaW5WZXJzaW9uID0gc3RhY2tzVmVyc2lvbjtcbiAgICAgICAgaWYgKEFERFJfU1RBQ0tTX1RPX0JJVENPSU5bc3RhY2tzVmVyc2lvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYml0Y29pblZlcnNpb24gPSBBRERSX1NUQUNLU19UT19CSVRDT0lOW3N0YWNrc1ZlcnNpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiaXRjb2luVmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGxldCBwcmVmaXggPSBiaXRjb2luVmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJlZml4ID0gYDAke3ByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKGhhc2gxNjBTdHJpbmcsIHByZWZpeCk7XG59XG5leHBvcnRzLmMzMlRvQjU4ID0gYzMyVG9CNTg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/base58check.js":
/*!**************************************************!*\
  !*** ./node_modules/c32check/lib/base58check.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\");\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix = '00') {\n    const dataBytes = typeof data === 'string' ? (0, utils_1.hexToBytes)(data) : data;\n    const prefixBytes = typeof prefix === 'string' ? (0, utils_1.hexToBytes)(prefix) : data;\n    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {\n        throw new TypeError('Argument must be of type Uint8Array or string');\n    }\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    return basex(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);\n}\nexports.encode = encode;\nfunction decode(string) {\n    const bytes = basex(ALPHABET).decode(string);\n    const prefixBytes = bytes.slice(0, 1);\n    const dataBytes = bytes.slice(1, -4);\n    // todo: for better performance replace spread with `concatBytes` method\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    bytes.slice(-4).forEach((check, index) => {\n        if (check !== checksum[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    return { prefix: prefixBytes, data: dataBytes };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJrYWRpa28tYmVnaW5uZXItd2l6YXJkLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9iYXNlNThjaGVjay5qcz8xNGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93emJnL2Jhc2U1OGNoZWNrXG4gKiBAQXV0aG9yOiB6eWNcbiAqIEBEYXRlOiAgIDIwMTYtMDktMTEgMjM6MzY6MDVcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgYmFzZXggPSByZXF1aXJlKFwiYmFzZS14XCIpO1xuY29uc3QgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSwgcHJlZml4ID0gJzAwJykge1xuICAgIGNvbnN0IGRhdGFCeXRlcyA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBwcmVmaXhCeXRlcyA9IHR5cGVvZiBwcmVmaXggPT09ICdzdHJpbmcnID8gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykocHJlZml4KSA6IGRhdGE7XG4gICAgaWYgKCEoZGF0YUJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgIShwcmVmaXhCeXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKG5ldyBVaW50OEFycmF5KFsuLi5wcmVmaXhCeXRlcywgLi4uZGF0YUJ5dGVzXSkpKTtcbiAgICByZXR1cm4gYmFzZXgoQUxQSEFCRVQpLmVuY29kZShbLi4ucHJlZml4Qnl0ZXMsIC4uLmRhdGFCeXRlcywgLi4uY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKHN0cmluZykge1xuICAgIGNvbnN0IGJ5dGVzID0gYmFzZXgoQUxQSEFCRVQpLmRlY29kZShzdHJpbmcpO1xuICAgIGNvbnN0IHByZWZpeEJ5dGVzID0gYnl0ZXMuc2xpY2UoMCwgMSk7XG4gICAgY29uc3QgZGF0YUJ5dGVzID0gYnl0ZXMuc2xpY2UoMSwgLTQpO1xuICAgIC8vIHRvZG86IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgcmVwbGFjZSBzcHJlYWQgd2l0aCBgY29uY2F0Qnl0ZXNgIG1ldGhvZFxuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHNoYTI1Nl8xLnNoYTI1NikobmV3IFVpbnQ4QXJyYXkoWy4uLnByZWZpeEJ5dGVzLCAuLi5kYXRhQnl0ZXNdKSkpO1xuICAgIGJ5dGVzLnNsaWNlKC00KS5mb3JFYWNoKChjaGVjaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGNoZWNrICE9PSBjaGVja3N1bVtpbmRleF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXhCeXRlcywgZGF0YTogZGF0YUJ5dGVzIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/checksum.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/checksum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBLHVDQUF1QyxXQUFXLEVBQUUsS0FBSztBQUN6RCxnREFBZ0QsS0FBSyxFQUFFLFlBQVk7QUFDbkUsY0FBYyx3QkFBd0IsRUFBRSxPQUFPO0FBQy9DO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQSx1QkFBdUIsV0FBVyxFQUFFLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Fya2FkaWtvLWJlZ2lubmVyLXdpemFyZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvY2hlY2tzdW0uanM/OTFjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYzMyY2hlY2tEZWNvZGUgPSBleHBvcnRzLmMzMmNoZWNrRW5jb2RlID0gdm9pZCAwO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG4vKipcbiAqIEdldCB0aGUgYzMyY2hlY2sgY2hlY2tzdW0gb2YgYSBoZXgtZW5jb2RlZCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhSGV4IC0gdGhlIGhleCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzIgY2hlY2tzdW0sIGFzIGEgYmluLWVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGMzMmNoZWNrc3VtKGRhdGFIZXgpIHtcbiAgICBjb25zdCBkYXRhSGFzaCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKGRhdGFIZXgpKSk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShkYXRhSGFzaC5zbGljZSgwLCA0KSk7XG4gICAgcmV0dXJuIGNoZWNrc3VtO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBoZXggc3RyaW5nIGFzIGEgYzMyY2hlY2sgc3RyaW5nLiAgVGhpcyBpcyBhIGxvdCBsaWtlIGhvd1xuICogYmFzZTU4Y2hlY2sgd29ya3MgaW4gQml0Y29pbi1sYW5kLCBidXQgdGhpcyBhbGdvcml0aG0gdXNlcyB0aGVcbiAqIHotYmFzZS0zMiBhbHBoYWJldCBpbnN0ZWFkIG9mIHRoZSBiYXNlNTggYWxwaGFiZXQuICBUaGUgYWxnb3JpdGhtXG4gKiBpcyBhcyBmb2xsb3dzOlxuICogKiBjYWxjdWxhdGUgdGhlIGMzMmNoZWNrc3VtIG9mIHZlcnNpb24gKyBkYXRhXG4gKiAqIGMzMmVuY29kZSB2ZXJzaW9uICsgZGF0YSArIGMzMmNoZWNrc3VtXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSB2ZXJzaW9uIHN0cmluZyAoYmV0d2VlbiAwIGFuZCAzMSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gdGhlIGRhdGEgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYzMyY2hlY2sgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gYzMyY2hlY2tFbmNvZGUodmVyc2lvbiwgZGF0YSkge1xuICAgIGlmICh2ZXJzaW9uIDwgMCB8fCB2ZXJzaW9uID49IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uIChtdXN0IGJlIGJldHdlZW4gMCBhbmQgMzEpJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5tYXRjaCgvXlswLTlhLWZBLUZdKiQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSAobm90IGEgaGV4IHN0cmluZyknKTtcbiAgICB9XG4gICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIGRhdGEgPSBgMCR7ZGF0YX1gO1xuICAgIH1cbiAgICBsZXQgdmVyc2lvbkhleCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIGlmICh2ZXJzaW9uSGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2ZXJzaW9uSGV4ID0gYDAke3ZlcnNpb25IZXh9YDtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tzdW1IZXggPSBjMzJjaGVja3N1bShgJHt2ZXJzaW9uSGV4fSR7ZGF0YX1gKTtcbiAgICBjb25zdCBjMzJzdHIgPSAoMCwgZW5jb2RpbmdfMS5jMzJlbmNvZGUpKGAke2RhdGF9JHtjaGVja3N1bUhleH1gKTtcbiAgICByZXR1cm4gYCR7ZW5jb2RpbmdfMS5jMzJbdmVyc2lvbl19JHtjMzJzdHJ9YDtcbn1cbmV4cG9ydHMuYzMyY2hlY2tFbmNvZGUgPSBjMzJjaGVja0VuY29kZTtcbi8qXG4gKiBEZWNvZGUgYSBjMzJjaGVjayBzdHJpbmcgYmFjayBpbnRvIGl0cyB2ZXJzaW9uIGFuZCBkYXRhIHBheWxvYWQuICBUaGlzIGlzXG4gKiBhIGxvdCBsaWtlIGhvdyBiYXNlNThjaGVjayB3b3JrcyBpbiBCaXRjb2luLWxhbmQsIGJ1dCB0aGlzIGFsZ29yaXRobSB1c2VzXG4gKiB0aGUgei1iYXNlLTMyIGFscGhhYmV0IGluc3RlYWQgb2YgdGhlIGJhc2U1OCBhbHBoYWJldC4gIFRoZSBhbGdvcml0aG1cbiAqIGlzIGFzIGZvbGxvd3M6XG4gKiAqIGV4dHJhY3QgdGhlIHZlcnNpb24sIGRhdGEsIGFuZCBjaGVja3N1bVxuICogKiB2ZXJpZnkgdGhlIGNoZWNrc3VtIG1hdGNoZXMgYzMyY2hlY2tzdW0odmVyc2lvbiArIGRhdGEpXG4gKiAqIHJldHVybiBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyZGF0YSAtIHRoZSBjMzJjaGVjay1lbmNvZGVkIHN0cmluZ1xuICogQHJldHVybnMge2FycmF5fSBbdmVyc2lvbiAobnVtYmVyKSwgZGF0YSAoc3RyaW5nKV0uICBUaGUgcmV0dXJuZWQgZGF0YVxuICogd2lsbCBiZSBhIGhleCBzdHJpbmcuICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBjaGVja3N1bSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gYzMyY2hlY2tEZWNvZGUoYzMyZGF0YSkge1xuICAgIGMzMmRhdGEgPSAoMCwgZW5jb2RpbmdfMS5jMzJub3JtYWxpemUpKGMzMmRhdGEpO1xuICAgIGNvbnN0IGRhdGFIZXggPSAoMCwgZW5jb2RpbmdfMS5jMzJkZWNvZGUpKGMzMmRhdGEuc2xpY2UoMSkpO1xuICAgIGNvbnN0IHZlcnNpb25DaGFyID0gYzMyZGF0YVswXTtcbiAgICBjb25zdCB2ZXJzaW9uID0gZW5jb2RpbmdfMS5jMzIuaW5kZXhPZih2ZXJzaW9uQ2hhcik7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBkYXRhSGV4LnNsaWNlKC04KTtcbiAgICBsZXQgdmVyc2lvbkhleCA9IHZlcnNpb24udG9TdHJpbmcoMTYpO1xuICAgIGlmICh2ZXJzaW9uSGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2ZXJzaW9uSGV4ID0gYDAke3ZlcnNpb25IZXh9YDtcbiAgICB9XG4gICAgaWYgKGMzMmNoZWNrc3VtKGAke3ZlcnNpb25IZXh9JHtkYXRhSGV4LnN1YnN0cmluZygwLCBkYXRhSGV4Lmxlbmd0aCAtIDgpfWApICE9PSBjaGVja3N1bSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYzMyY2hlY2sgc3RyaW5nOiBjaGVja3N1bSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3ZlcnNpb24sIGRhdGFIZXguc3Vic3RyaW5nKDAsIGRhdGFIZXgubGVuZ3RoIC0gOCldO1xufVxuZXhwb3J0cy5jMzJjaGVja0RlY29kZSA9IGMzMmNoZWNrRGVjb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/encoding.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/encoding.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for (let i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for (let i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error('Not a c32-encoded string');\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for (let i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    let hexLeadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    let hexStr = res.join('');\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for (let i = 0; i < count; i += 2) {\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLFdBQVc7QUFDMUUsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQywwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Fya2FkaWtvLWJlZ2lubmVyLXdpemFyZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvZW5jb2RpbmcuanM/MDJhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYzMyZGVjb2RlID0gZXhwb3J0cy5jMzJub3JtYWxpemUgPSBleHBvcnRzLmMzMmVuY29kZSA9IGV4cG9ydHMuYzMyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuZXhwb3J0cy5jMzIgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonO1xuY29uc3QgaGV4ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuLyoqXG4gKiBFbmNvZGUgYSBoZXggc3RyaW5nIGFzIGEgYzMyIHN0cmluZy4gIE5vdGUgdGhhdCB0aGUgaGV4IHN0cmluZyBpcyBhc3N1bWVkXG4gKiB0byBiZSBiaWctZW5kaWFuIChhbmQgdGhlIHJlc3VsdGluZyBjMzIgc3RyaW5nIHdpbGwgYmUgYXMgd2VsbCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRIZXggLSB0aGUgaW5wdXQgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoIC0gdGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBjMzIgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYzMyY2hlY2stZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSwgYXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyZW5jb2RlKGlucHV0SGV4LCBtaW5MZW5ndGgpIHtcbiAgICAvLyBtdXN0IGJlIGhleFxuICAgIGlmICghaW5wdXRIZXgubWF0Y2goL15bMC05YS1mQS1GXSokLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBoZXgtZW5jb2RlZCBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0SGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgaW5wdXRIZXggPSBgMCR7aW5wdXRIZXh9YDtcbiAgICB9XG4gICAgaW5wdXRIZXggPSBpbnB1dEhleC50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGZvciAobGV0IGkgPSBpbnB1dEhleC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FycnkgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29kZSA9IGhleC5pbmRleE9mKGlucHV0SGV4W2ldKSA+PiBjYXJyeTtcbiAgICAgICAgICAgIGxldCBuZXh0Q29kZSA9IDA7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHRDb2RlID0gaGV4LmluZGV4T2YoaW5wdXRIZXhbaSAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhcnJ5ID0gMCwgbmV4dEJpdHMgaXMgMSwgY2FycnkgPSAxLCBuZXh0Qml0cyBpcyAyXG4gICAgICAgICAgICBjb25zdCBuZXh0Qml0cyA9IDEgKyBjYXJyeTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRMb3dCaXRzID0gbmV4dENvZGUgJSAoMSA8PCBuZXh0Qml0cykgPDwgKDUgLSBuZXh0Qml0cyk7XG4gICAgICAgICAgICBjb25zdCBjdXJDMzJEaWdpdCA9IGV4cG9ydHMuYzMyW2N1cnJlbnRDb2RlICsgbmV4dExvd0JpdHNdO1xuICAgICAgICAgICAgY2FycnkgPSBuZXh0Qml0cztcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KGN1ckMzMkRpZ2l0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgQzMybGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzW2ldICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQzMybGVhZGluZ1plcm9zKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzID0gcmVzLnNsaWNlKEMzMmxlYWRpbmdaZXJvcyk7XG4gICAgY29uc3QgemVyb1ByZWZpeCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShpbnB1dEhleCkpLm1hdGNoKC9eXFx1MDAwMCovKTtcbiAgICBjb25zdCBudW1MZWFkaW5nWmVyb0J5dGVzSW5IZXggPSB6ZXJvUHJlZml4ID8gemVyb1ByZWZpeFswXS5sZW5ndGggOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTGVhZGluZ1plcm9CeXRlc0luSGV4OyBpKyspIHtcbiAgICAgICAgcmVzLnVuc2hpZnQoZXhwb3J0cy5jMzJbMF0pO1xuICAgIH1cbiAgICBpZiAobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gbWluTGVuZ3RoIC0gcmVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdChleHBvcnRzLmMzMlswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbn1cbmV4cG9ydHMuYzMyZW5jb2RlID0gYzMyZW5jb2RlO1xuLypcbiAqIE5vcm1hbGl6ZSBhIGMzMiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJpbnB1dCAtIHRoZSBjMzItZW5jb2RlZCBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGMzMiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMybm9ybWFsaXplKGMzMmlucHV0KSB7XG4gICAgLy8gbXVzdCBiZSB1cHBlci1jYXNlXG4gICAgLy8gcmVwbGFjZSBhbGwgTydzIHdpdGggMCdzXG4gICAgLy8gcmVwbGFjZSBhbGwgSSdzIGFuZCBMJ3Mgd2l0aCAxJ3NcbiAgICByZXR1cm4gYzMyaW5wdXQudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvTHxJL2csICcxJyk7XG59XG5leHBvcnRzLmMzMm5vcm1hbGl6ZSA9IGMzMm5vcm1hbGl6ZTtcbi8qXG4gKiBEZWNvZGUgYSBjMzIgc3RyaW5nIGJhY2sgaW50byBhIGhleCBzdHJpbmcuICBOb3RlIHRoYXQgdGhlIGMzMiBpbnB1dFxuICogc3RyaW5nIGlzIGFzc3VtZWQgdG8gYmUgYmlnLWVuZGlhbiAoYW5kIHRoZSByZXN1bHRpbmcgaGV4IHN0cmluZyB3aWxsXG4gKiBiZSBhcyB3ZWxsKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJpbnB1dCAtIHRoZSBjMzItZW5jb2RlZCBpbnB1dCB0byBkZWNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGggLSB0aGUgbWluaW11bSBsZW5ndGggb2YgdGhlIG91dHB1dCBoZXggc3RyaW5nIChpbiBieXRlcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZXgtZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSwgYXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyZGVjb2RlKGMzMmlucHV0LCBtaW5MZW5ndGgpIHtcbiAgICBjMzJpbnB1dCA9IGMzMm5vcm1hbGl6ZShjMzJpbnB1dCk7XG4gICAgLy8gbXVzdCByZXN1bHQgaW4gYSBjMzIgc3RyaW5nXG4gICAgaWYgKCFjMzJpbnB1dC5tYXRjaChgXlske2V4cG9ydHMuYzMyfV0qJGApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgYzMyLWVuY29kZWQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHplcm9QcmVmaXggPSBjMzJpbnB1dC5tYXRjaChgXiR7ZXhwb3J0cy5jMzJbMF19KmApO1xuICAgIGNvbnN0IG51bUxlYWRpbmdaZXJvQnl0ZXMgPSB6ZXJvUHJlZml4ID8gemVyb1ByZWZpeFswXS5sZW5ndGggOiAwO1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBjYXJyeUJpdHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSBjMzJpbnB1dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FycnlCaXRzID09PSA0KSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdChoZXhbY2FycnldKTtcbiAgICAgICAgICAgIGNhcnJ5Qml0cyA9IDA7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudENvZGUgPSBleHBvcnRzLmMzMi5pbmRleE9mKGMzMmlucHV0W2ldKSA8PCBjYXJyeUJpdHM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRDb2RlICsgY2Fycnk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZXhEaWdpdCA9IGhleFtjdXJyZW50VmFsdWUgJSAxNl07XG4gICAgICAgIGNhcnJ5Qml0cyArPSAxO1xuICAgICAgICBjYXJyeSA9IGN1cnJlbnRWYWx1ZSA+PiA0O1xuICAgICAgICBpZiAoY2FycnkgPiAxIDw8IGNhcnJ5Qml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYW5pYyBlcnJvciBpbiBkZWNvZGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXMudW5zaGlmdChjdXJyZW50SGV4RGlnaXQpO1xuICAgIH1cbiAgICAvLyBvbmUgbGFzdCBjYXJyeVxuICAgIHJlcy51bnNoaWZ0KGhleFtjYXJyeV0pO1xuICAgIGlmIChyZXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICByZXMudW5zaGlmdCgnMCcpO1xuICAgIH1cbiAgICBsZXQgaGV4TGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzW2ldICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4TGVhZGluZ1plcm9zKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzID0gcmVzLnNsaWNlKGhleExlYWRpbmdaZXJvcyAtIChoZXhMZWFkaW5nWmVyb3MgJSAyKSk7XG4gICAgbGV0IGhleFN0ciA9IHJlcy5qb2luKCcnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUxlYWRpbmdaZXJvQnl0ZXM7IGkrKykge1xuICAgICAgICBoZXhTdHIgPSBgMDAke2hleFN0cn1gO1xuICAgIH1cbiAgICBpZiAobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gbWluTGVuZ3RoICogMiAtIGhleFN0ci5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgICAgICAgaGV4U3RyID0gYDAwJHtoZXhTdHJ9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGV4U3RyO1xufVxuZXhwb3J0cy5jMzJkZWNvZGUgPSBjMzJkZWNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/c32check/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\nObject.defineProperty(exports, \"c32encode\", ({ enumerable: true, get: function () { return encoding_1.c32encode; } }));\nObject.defineProperty(exports, \"c32decode\", ({ enumerable: true, get: function () { return encoding_1.c32decode; } }));\nObject.defineProperty(exports, \"c32normalize\", ({ enumerable: true, get: function () { return encoding_1.c32normalize; } }));\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nObject.defineProperty(exports, \"c32checkEncode\", ({ enumerable: true, get: function () { return checksum_1.c32checkEncode; } }));\nObject.defineProperty(exports, \"c32checkDecode\", ({ enumerable: true, get: function () { return checksum_1.c32checkDecode; } }));\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/c32check/lib/address.js\");\nObject.defineProperty(exports, \"c32address\", ({ enumerable: true, get: function () { return address_1.c32address; } }));\nObject.defineProperty(exports, \"c32addressDecode\", ({ enumerable: true, get: function () { return address_1.c32addressDecode; } }));\nObject.defineProperty(exports, \"c32ToB58\", ({ enumerable: true, get: function () { return address_1.c32ToB58; } }));\nObject.defineProperty(exports, \"b58ToC32\", ({ enumerable: true, get: function () { return address_1.b58ToC32; } }));\nObject.defineProperty(exports, \"versions\", ({ enumerable: true, get: function () { return address_1.versions; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN2TixtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2QyxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGtCQUFrQixtQkFBTyxDQUFDLCtEQUFXO0FBQ3JDLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksNENBQTJDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2pILDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcmthZGlrby1iZWdpbm5lci13aXphcmQvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzPzA4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmI1OFRvQzMyID0gZXhwb3J0cy5jMzJUb0I1OCA9IGV4cG9ydHMudmVyc2lvbnMgPSBleHBvcnRzLmMzMm5vcm1hbGl6ZSA9IGV4cG9ydHMuYzMyYWRkcmVzc0RlY29kZSA9IGV4cG9ydHMuYzMyYWRkcmVzcyA9IGV4cG9ydHMuYzMyY2hlY2tEZWNvZGUgPSBleHBvcnRzLmMzMmNoZWNrRW5jb2RlID0gZXhwb3J0cy5jMzJkZWNvZGUgPSBleHBvcnRzLmMzMmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmVuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RpbmdfMS5jMzJlbmNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJkZWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kaW5nXzEuYzMyZGVjb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMybm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGluZ18xLmMzMm5vcm1hbGl6ZTsgfSB9KTtcbmNvbnN0IGNoZWNrc3VtXzEgPSByZXF1aXJlKFwiLi9jaGVja3N1bVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmNoZWNrRW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVja3N1bV8xLmMzMmNoZWNrRW5jb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyY2hlY2tEZWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc3VtXzEuYzMyY2hlY2tEZWNvZGU7IH0gfSk7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyYWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmMzMmFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJhZGRyZXNzRGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEuYzMyYWRkcmVzc0RlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMlRvQjU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEuYzMyVG9CNTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiNThUb0MzMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmI1OFRvQzMyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS52ZXJzaW9uczsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/c32check/node_modules/base-x/src/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Fya2FkaWtvLWJlZ2lubmVyLXdpemFyZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz9jZGZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKVxuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGNvZGUgb2YgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhciBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBzeilcbiAgICAgICAgICAgIC8vIEJhc2UgbWFwIGNhbiBub3QgYmUgaW5kZXhlZCB1c2luZyBjaGFyIGNvZGVcbiAgICAgIGlmIChjaGFyQ29kZSA+IDI1NSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbY2hhckNvZGVdXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\n");

/***/ })

};
;